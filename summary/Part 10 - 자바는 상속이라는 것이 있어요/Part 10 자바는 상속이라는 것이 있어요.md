# Part 10: 자바는 상속이라는 것이 있어요

### 개요

객체지향을 가능하게 만들어주는 중요한 요소 중 하나인 상속에 대해 알아봅니다.

---

### 상속이란

- 상속이란 우리가 부모님에게 무언가를 물려받는 것과 동일합니다. 부모클래스가 가진 것들을 자식 클래스가 물려받아 사용할 수 있게 되는 것입니다.
    - 자바에서는 부모클래스에게 여러 자원들을 물려받은 후 확장이 가능합니다. 상속에 사용되는 키워드가 extend 인 것을 보면 알 수 있습니다.
    - extends 키워드를 사용해 특정 클래스를 상속하면 그 때부터 상속하는 쪽이 자식, 상속을 당하는 쪽이 부모 클래스가 됩니다.
        - 사실 우리가 사용하는 모든 클래스는 Object 클래스를 상속하고 있습니다.
    - public, protected 제어자를 갖는 메서드, 변수는 자식 클래스에서 모두 사용 가능합니다.
        - private, package-private은 자식 클래스에서 상속되지 않습니다. private은 자신만 접근 가능하고, package-private은 같은 패키지 내에서만 사용 가능하기 때문입니다.
    - 자식 클래스는 인스턴스 생성 시 부모 클래스를 먼저 생성한 뒤 자신의 인스턴스를 생성합니다.
        - 부모 클래스를 생성할 때 사용되는 생성자는 매개 변수가 없는 기본 생성자입니다.

---

### 상속을 통한 재사용

- 상속을 통한 재사용은 중복 코드를 없애고 다른 부분만 추가하거나 재정의하는 것을 통해 손쉬운 기능 확장을 가능케 합니다.
    - 클래스 상속은 부모 클래스의 내부가 자식 클래스에게 공개되는 것때문에 **화이트박스 재사용(white-box reuse)**이라고 불립니다.
- 하지만 상속은 여러 문제점을 가지고 있습니다.
    1. **높은 결합도**
        
        상속은 부모 클래스의 구현 코드 자체를 재사용합니다. 메서드와 변수를 호출해 자신만의 로직을 재구성할 수 있습니다. 즉 자식 클래스가 부모 클래스의  내부 구현에 상세하게 알게 됩니다. 이 때문에 캡슐화가 깨지게 되며 부모 클래스와의 결합도도 높아집니다.
        
    2. **취약한 기반 클래스 문제**
        
        부모 클래스의 메서드를 변경해야할 때 이를 상속하는 모든 자식 클래스에게 변경의 영향이 가해집니다. 이렇게 상속 관계때문에 자식 클래스가 변경에 취약해지는 현상을 **취약한 기반 클래스 문제**라고 합니다.
        
    3. **불필요한 인터페이스 상속 문제**
        
        상속받은 부모 클래스으 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있습니다.
        
    4. **메서드 오버라이딩의 오작용 문제**
        
        자식 클래스가 메서드 오버라이딩할 경우 부모 클래스의 메서드 활용 방식에 자식 클래스가 결합될 수 있습니다.
        
    5. **부모 클래스와 자식 클래스의 동시 수정 문제**
        
        앞서 말한 것처럼 상속 관계에선 부모 자식 클래스가 높은 결합도를 갖고 있기 때문에 우린 둘의 구현을 아예 변경하지 않거나 동시에 변경해야 합니다.
        
    - 자바에선 다이아몬드 문제때문에 다중 상속을 지원하지 않습니다.
        - 다이아몬드 문제란 다중 상속을 수행했을 때 만약 부모클래스에서 메서드 시그니처가 동일한 메서드가 존재한다고 가정했을 때 자식 클래스에서 어떤 메서드를 가리키는지 알 수 없는 문제를 말합니다.

---

### super

- 자식 클래스에선 super를 사용해 부모 클래스의 생성자,메서드를 호출할 수 있습니다.
    - 생성자: `super(), super(param)`
    - 메서드: `super.methodInParentClass()`

---

### 메서드 오버라이딩

- 자식 클래스에선 부모 클래스의 메서드를 재정의할 수 있습니다.
    - 메서드 시그니처에 제약이 존재합니다.
        - 인자와 리턴 타입이 동일해야 합니다.
        - 접근 제어자는 동일하거나 접근 권한이 확장된 상태로 선언되어야 합니다. 아닌 경우 컴파일 에러가 발생합니다.

---

### 참조 자료형의 형변환

- 참조 자료형은 자신의 부모 클래스 타입을 갖는 참조 변수에 자식 클래스의 인스턴스를 할당할 수 있다. 하지만 그 반대는 불가능하다.
    - 자식 클래스는 부모 클래스를 상속받는다. 부모 클래스에 선언된 내용들을 자식 클래스가 전부 알고 있고 호출이 가능하기 때문에 할당이 가능하다.
    - 하지만 자식 클래스는 상속 후에 확장의 가능성이 있기 때문에 부모 클래스가 알지 못하는 내용들이 존재할 가능성이 있다. 따라서 할당이 불가능하다.
        - 만약 가능하게 하려면 자식 클래스 타입의 변수를 생성하고 부모 클래스 타입의 참조 변수에 할당한 뒤 이를 다시 자식 클래스로 명시적 형변환하면 된다.
        - 굳이 이렇게까지 할 필요는 없어보인다.
    - 이것이 바로 객체지향의 다형성이다.
- instanceof를 통해 객체가 해당 클래스 타입인지를 검증할 수 있다.
    - 이는 특정 메서드에서 인자로 들어오는 클래스의 타입을 검증하는 과정이 필요하다는 것을 의미한다.
        - 따라서 SOLID 원칙 중 OCP 원칙의 안티 패턴으로 불린다.

---

### Polymorphism(다형성)

- 다형성은 **하나의 타입으로 선언되어 있지만 여러 다른 타입의 동작을 수행하는 것**을 의미한다.
    - 위 예시처럼 부모 클래스 타입으로 선언된 참조 변수에 자식 클래스의 인스턴스들이 할당되어 동작하는 것을 말한다.
        - 부모 클래스의 퍼블릭 인터페이스 중 동일한 메서드를 호출하더라도 어떤 자식 클래스 인스턴스가 할당되었느냐에 따라 (각자 확장한 내용이 다를테니) 서로 다른 형태로 동작한다.