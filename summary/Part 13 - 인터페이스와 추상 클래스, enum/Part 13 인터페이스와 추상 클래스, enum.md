# Part 13: 인터페이스와 추상 클래스, enum

### 개요

자바의 인터페이스, 추상 클래스, enum에 대해서 알아봅니다.

---

### interface

- 인터페이스는 설계 단계에서 그리는 프로그램의 청사진처럼 클래스의 명세 역할을 담당합니다.
    - 프로그램 설계도는 건설(구현)이 완료된 건물이 아닙니다. 완료된 결과물의 뼈대를 나타냅니다.
    - 실제 구현을 몰라도 어떤 것을 동작시킬 수 있는 도구를 의미합니다.
        - 자동차의 핸들과 비교해보면 우린 오른쪽으로 핸들을 돌릴 때 오른쪽으로 과연 움직일까? 어떻게 움직일까? 생각하며 돌리지 않습니다. 당연히 오른쪽으로 움직일거라 믿고 돌립니다. 인터페이스 역시 그런 것입니다.
        - 세부 구현을 모른채 동작에만 집중할 수 있도록 하나의 인다이렉션이 되어줍니다.
    - 설계 단계에서 작성해놓으면 기능 구현에 집중할 수 있습니다.
        - 인터페이스는 설계이기 때문에 구현에 필요한 메서드 블록 내부를 갖지 않습니다.
        - 임의의 클래스를 생성하고 implements 키워드를 통해 인터페이스를 상속(구현)할 수 있습니다.
        - implements를 통해 상속받은 경우 반드시 전부 구현해야 합니다.
    - 인터페이스는 객체가 구현할 경우 퍼블릭 인터페이스의 역할을 합니다. 외부 클라이언트들에게 내가 어떤 기능들을 수행할 수 있는지 보여주는 하나의 문서가 됩니다.
- 인터페이스의 핵심은 인다이렉션의 역할을 통한 다형성입니다.
    - 참조 변수의 타입을 인터페이스로 선언하고 인터페이스를 구현한 구체 클래스를 할당합니다. 외부에는 인터페이스에 선언한 퍼블릭 인터페이스들을 보여주고 실제 메서드 실행은 구현체를 참조해 수행합니다.
    - 외부로부터 구현체의 세부 구현을 안전하게 캡슐화하고 이를 사용하는 클라이언트와의 의존성도 인터페이스한테로 미룰 수 있습니다. 이를 통해 낮은 결합도를 유지합니다.

---

### 추상 클래스

- 그런데 인터페이스 중에는 한번 정의되면 다시는 바뀌지 않을 것 같은 메서드들도 있습니다. 이를 위해 필요한 것이 추상 클래스입니다.
    - 클래스명 앞에 abstract 키워드를 붙혀 추상 클래스로 만들 수 있습니다.
    - extends 키워드를 통해 상속받아 확장할 수 있습니다.
    - 추상 클래스는 자식 클래스에서 구현할 수 있도록 구현부가 없는 추상 메서드를 선언할 수도 있고 구현부가 있는 일반 메서드를 선언할 수도 있습니다. 추상 메서드가 없어도 상관 없습니다.
    - 둘다 상속을 기반으로 동작하지만 추상 클래스 역시 부모-자식 클래스의 상속 관계에서 발생하는 문제점들을 갖습니다.

---

### final

- 상태의 변경을 막기 위해 사용하는 키워드입니다. 불변 객체는 따로 논하겠습니다.
    - 클래스에 선언 시 상속이 불가능해집니다.
        - 더 이상 확장되서는 안되는 클래스에 선언합니다. 앞서 말했듯 내부의 상태(내용)이 변경되서는 안되는 경우입니다. 자바에서는 String이 대표적인 final 클래스입니다.
    - 메서드에 선언 시 오버라이딩이 불가능해집니다.
    - 변수에 선언 시 내부의 상태 변경이 불가능합니다.
        - 인스턴스, 클래스 변수는 선언과 동시에 혹은 생성자에서 반드시 값이 지정되어야 합니다. 하지만 생성자에서 초기화되는 경우 중복된 변수값이 선언될 우려가 있기 때문에 생성과 동시에 초기화를 권장합니다.
        - 매개변수나 지역 변수의 경우 반드시 초기화할 필요는 없습니다. 하지만 상태 변경이 불가능하다는 점은 동일합니다. 만약 상태 변경을 시도하면 컴파일 에러가 발생합니다.
    - final로 선언한 인스턴스 변수가 참조형 객체인 경우 실제로는 불변이 아닐수도 있습니다.
        - 해당 클래스가 final이라고 해서, 그 안에 있는 인스턴스 변수나 클래스 변수까지 final은 아닙니다.

---

### enum

- 서로 관계있는 상수들의 집합을 표현하기 위한 클래스입니다.
    - 이전에 상수를 클래스나 인터페이스를 사용해 정의하던 방식보다 장점이 많습니다.
        - 코드가 훨씬 단순해지며 가독성이 좋습니다.
        - 인스턴스의 생성과 상속을 방지합니다.
        - 클래스의 의도가 열거임을 명확하게 드러냅니다.
    - 생성자는 package-private, private만 가능합니다. public, protected로 선언 시 컴파일 에러가 발생합니다.
        - new 연산자를 통한 인스턴스 생성 역시 불가능합니다.
        - 인스턴스 생성의 제어를 통해 싱글톤 인스턴스를 보장합니다.
    - 각 열겨형의 필드를 선언하는 것도 가능합니다.
        - 최초 생성 시 할당된 채로 변경이 불가능합니다.
- enum 클래스의 부모 클래스는 반드시 `java.lang.Enum` 이어야 합니다.
    - 별도로 사용자가 명시하진 않지만 컴파일러가 상속 구문(`extends java.lang.Enum`)을 자동으로 추가해줍니다.
    - enum 클래스 역시 최종 부모 클래스는 Objcet 클래스입니다. 하지만 clone(), finalize(), hashcode(), equals() 메서드에 대한 오버라이딩은 금지되어 있습니다.