# godOfJava Part 1. 대답할 수 있나요?

### 개요

단순하게 ‘아는 것’이 아닌 ‘아는 것을 설명할 수 있는 힘’을 기르기 위한 질문들과 그 답변을 준비합니다. 되도록 20초 안으로 핵심을 추출해 답변하도록 합니다.

---

### OOP, 상속

- **객체와 클래스**
    - [x]  *클래스와 객체의 차이점은 무엇일까요?*
    - 객체는 프로그래밍 기능의 분해 시 책임을 분배하기 위한 개념적인 요소라고 생각합니다. 클래스는 이러한 객체를 표현하기 위한 객체지향 언어의 도구입니다.
        - [x]  *객체의 책임이란 무엇인가요?*
        - 책임이란 자신이 담당하는 프로그램의 기능입니다. 그런 의미에서 객체지향 패러다임이란 만들어야 하는 요구사항들을 객체들에게 적절하게 나누는 과정을 통해 프로그램을 설계하는 것이라고 생각합니다.
            - [ ]  *절차적 프로그래밍과는 어떤 점이 다르며 서로 어떤 장단점이 있을까요?*
                - TODO
    - [x]  메서드와 메시지는 무엇이 다를까요?
        - 메서드는 객체가 메시지를 수신했을 때 자신의 책임을 수행하기 위해 선택하는 방법입니다. 따라서 메서드는 실제 책임을 수행하기 위한 구현 방법, 코드를 의미합니다. 반면 메시지는 객체가 소통하는 방법을 의미합니다.
    - [x]  캡슐화가 필요한 이유가 무엇일까요?
        - 객체들이 서로의 세부 구현을 모르도록 만들어 **협력의 유연함을 증가시키고, 이를 통해 변경의 파급효과를 적절하게 통제**하기 위해서입니다.
        - 객체는 서로 퍼블릭 인터페이스를 커뮤니케이션합니다. 만약 캡슐화가 되어있지 않아 세부 구현에 대해 마음대로 접근할 수 있다면 객체 사이의 결합도가 늘어나게 됩니다.
            - 예를 들어 더하기라는 기능을 구현한다고 가정하겠습니다. 더하기에는 좌변에 수를 놓기, 우변에 수를 놓기, 더하기라는 세 개의 동작이 필요합니다.
            - 만약 요청 객체가 좌변에 수를 놓기를 직접 가져다 쓴다면 나중에 좌변에 수를 놓는 동작이 변경되었을 때 그 객체도 변경되어야 합니다. 이것은 변경의 파급효과를 제어하지 못하는 것을 의미합니다.
        - 따라서 캡슐화를 통해 변경이 적고 세부 구현을 감추는 퍼블릭 인터페이스만 노출시키는 것은 협력의 유연함을 늘리고 객체 간의 결합도를 줄일 수 있는 장점을 갖고 있기 때문에 필요합니다.
- **다형성(Polymorphism)**
    - [x]  Polymorphism, 다형성이란 무엇일까요?
        - 동일한 메시지를 수신하더라도 객체의 타입에 따라 다르게 응답할 수 있는 성질을 말합니다. 인터페이스와 다형성을 통해서 객체지향에서는 컴파일 타임의 의존성을 제어할 수 있습니다.
            - [x]  어떻게 인터페이스와 다형성을 통해 제어하는지 설명해주세요.
            - 컴파일 시점에서는 부모 클래스의 메서드인지, 자식 클래스의 메서드인지 구별하지 않고 동일한 메서드를 호출하지만 런타임에서 어떤 객체가 할당되어있는지에 따라 실행 결과가 달라집니다. 이를 통해 컴파일 타임의 의존성을 해결할 수 있습니다.
            - 정책과 구현체의 의존성 방향 모두 인터페이스를 향하게 됩니다.
    - [x]  메서드 오버로딩이란 무엇일까요? 메서드 오버라이딩이란 무엇인가요? 그리고 둘은 무엇이 다른가요?
        - [오브젝트 PART 12 - 다형성](https://www.notion.so/PART-12-bdd9bdad96df48d68fefc0f564565c1f)
        - 메서드 오버로딩이란?
            - 메서드 오버로딩이란 인자의 타입이나 수를 변경하여도 동일한 메서드 시그니처를 가지는 것을 허용해주는 기술입니다. 이를 통해 유사한 작업을 수행하는 메서드의 이름을 손쉽게 압축할 수 있습니다.
                - 예를 들어 plus() 메서드를 구현할 때 단순한 숫자일수도, 돈일수도 있는데 이런 경우 사용이 가능합니다. 메서드 오버로딩은 컴파일 타임 시점에서 호출될 메서드의 종류를 선택하는 정적 메서드 디스패칭을 사용합니다.
        - 메서드 오버라이딩이란?
            - 부모 클래스로부터 상속받은 메서드와 동일한 시그니처의 메서드를 재정의해서 새로운 구현으로 부모 클래스의 구현을 대체하는 것을 말합니다.
            - 이를 위해 필요한 것은 부모 클래스 타입 변수에 자식 클래스 인스턴스를 할당하는 업캐스팅과 런타임 시점에 실행할 메서드를 탐색하는 다이나믹 메서드 디스패칭입니다.
                - 다이나믹 메서드 디스패칭이 수행될 때 중요한 것은 self 참조라는 임시변수입니다. 컴파일러는 self 참조라는 임시변수를 자동으로 생성하고 메시지를 수신한 객체를 가리킵니다. 여기서 부모 클래스 방향으로 올라가며 일치하는 메시지가 존재하는지를 확인합니다.
                - 여기서 메서드 탐색은 메서드를 찾지 못한다면 자동적으로 부모 클래스에게 메서드에 대한 책임을 위임합니다.
- **추상 클래스, 인터페이스**
    - [x]  추상 클래스와 인터페이스에 대해 설명해주세요
        - 추상 클래스는 상속 관계를 갖는 클래스들 사이에서 세부 구현을 공유해야할 필요가 있을 때, 즉 코드 재사용을 위해 사용됩니다.
        - 인터페이스는 클래스들 사이에서 객체들의 책임만 정의하고 싶을 때 사용됩니다. 인터페이스는 주로 다형성을 통해 컴파일 타임 의존성을 끊어내기 위해 주로 사용됩니다.

- **SOLID Foundation**
    - [ ]  SOLID 원칙에 대해서 설명해주세요
    - 로버트 마틴 aka 엉클밥이 명명한 객체지향에서 변경의 영향을 최소화할 수 있는 좋은 설계를 만들기 위한 원칙을 마이클 페더스가 앞글자만 따서 소개한 것입니다. 좋은 설계는 DI로 IoC 구조를 만들어서 상위 레벨 정책과 하위 레벨 구현 사이를 절연시키고 이를 통해 모듈 사이의 의존성을 적절하게 관리하는 설계라고 생각합니다. 원칙은 총 5가지로 이루어져 있는데요. 단일 책임 원칙, 확장 페쇄 원칙, 리스코프 치환 원칙, 인터페이스 분리 원칙, 의존성 역전 원칙입니다.
---

### Java

- **자료형**
    - [x]  기본 자료형과 참조 자료형이 메모리 상에서 저장되는 위치는 어디일까요?
        - 두 데이터 모두 JVM 내부의 Runtime data area에 저장됩니다. 그 중 기본 자료형은 각 쓰레드의 고유한 스택 공간에 스택 프레임 형태로 저장됩니다. 참조 자료형은 Heap 영역에 저장됩니다. 만약 String 클래스라면 Heap 영역 중 String Constant Pool에 저장됩니다.
        - [x]  스택 프레임은 어떤 구조로 이루어져 있나요?
            - 스택 프레임은 메서드의 지역 변수를 저장하는 Local Variable Section, 연산에 이용되는 데이터 및 결과를 저장하는 Operand Stack, Frame Data로 이루어져 있습니다.
            - 최상단 스택 프레임을 current frame이라고 부릅니다.
                - Local Variable Section는 0-Base 배열로 구성되어있고 로컬 변수와 메서드 파라미터가 저장됩니다.
                - Operand Stack에는 연산에 사용되는 값들이 저장됩니다.
                - Frame Data에는 다른 클래스를 참조하거나 메서드를 수행할 때 Constant Pool Resolution, Normal Method Return, Exception Dispatch가 있습니다.
    - [x]  (설로인) 컴퓨터는 소숫점 계산을 잘 못합니다. 그 이유가 무엇일까요? 어떻게 문제를 해결할 수 있을까요? 직접 구현한다면 어떻게 하시겠습니까?
        - 이유는 부동 소수점을 표현하기 위한 IEEE 754를 사용합니다.
            - [x]  *왜 IEEE 754 기술을 사용할까요?*
            - 고정 소수점은 정수부와 소수부의 크기를 제한합니다. 즉 비트를 효율적으로 사용하지 못하는 것이죠. 따라서 과학적 표기법을 통해 유효한 숫자만 표시할 수 있도록 하기 위해 부동 소수점 방식을 사용합니다.
            - 그리고 이렇게 소수점을 소수부의 가장 첫번째 자리까지 당겨오는 것을 정규화라고 합니다.
        - 하지만 부동 소수점은 가수의 자리수를 32비트에서는 23자리, 64비트에서는 52자리로 제한하기 때문에 표현하고자 하는 소수부의 이진법 표기가 무한소수로 표기되는 경우 결국 일부분을 잘라낼 수 밖에 없게 됩니다. 이 때문에 값의 오차가 발생합니다.
            - [x]  *32비트에서 64비트로 올라가면 정밀도가 향상됩니다. 정밀도란 무엇일까요?*
                - 말 그대로 숫자의 오차를 줄이는 법이라고 생각합니다. 위에서 말했듯 비트 크기의 한계 때문에 결국 일부분이 끊기는데, 비트 크기가 크다면 최대한 잘리는 비트의 수가 적어질 것이고 실제값에 더 가까워질 수 있습니다.
        - [x]  *자바에서 BigDecimal은 어떻게 이런 문제를 해결할까요?*
            - 수를 내부적으로 10진수로 저장합니다. 부동소수점에서 문제가 되는 부분는 가수를 2진수로 표현하려 했기 때문이었습니다. 하지만 10진수로 표현한다면 위 오차를 없앨 수 있습니다.
    - [ ]  pass by value, pass by reference에 대해서 설명해주세요
        - 메서드의 매개변수가 전달될 때 인자의 자료형에 따라 ‘값' 혹은 ‘주소’가 전달되는 것을 말합니다. 인자가 프리미티브 타입인 경우는 **복사된 값만 전달**됩니다. 즉 원본에 영향을 끼칠 수 없습니다. 반면 참조형 객체는 ‘주소'가 전달되기 때문에 만약 메서드 내부에서 해당 인스턴스의 상태에 수정을 시도하는 경우 원본에 영향이 미치게 됩니다. 만약 내부에서 다른 객체로 대체하는 경우는 영향을 받지 않는다.
            - [ ]  복사된 값만 전달된다는 것을 JVM의 스택 프레임과 연관지어 설명해주세요
            - JVM의 Runtime data area에는 각 쓰레드별로 상태값을 저장하기 위한JVM Stack이 생성됩니다.
            - JVM Stack Area는 공유되지 않는 영역으로 메서드가 호출될 때마다 Stack Frame이라는 자료구조가 스택 영역에 적재됩니다. 해당 값들은 Stack Frame의 Local Variable에 값이 올라가거나 메모리 주소가 올라가게 됩니다.
- **형 변환**
    - [ ]  auto boxing, unboxing 이란 무엇인가요?
    - Wrapper 클래스와 primitive 사이에서 서로간 캐스팅을 해주는 것을 말합니다.
    - 프리미티브 타입 값이 래퍼 타입으로 선언된 파라미터를 통과할 때
        - 어떻게 가능하냐?
    - [ ]  업캐스팅과 다운캐스팅
- **static**
    - [ ]  static 변수, static 메서드는 일반 인스턴스 변수, 인스턴스 메서드와 어떤 점이 다른가요?
    - [ ]  스태틱 변수는 JVM 런타임 메모리 중 어디에 올라가나요?
- **Object Class**
    - [ ]  Object가 지원하는 `hashcode()`, `equals()` 메서드에 대해서 설명해주세요.
- **Enum Class**
    - [ ]  Enum 클래스가 무엇인가요?
- **final keyword**
    - [ ]  자바에서 final 키워드는 어떤 역할을 하나요?
- **Exception**
    - [ ]  예외 종류에 대해 설명해주세요.
    - [ ]  try and resource에 대해서 설명해주세요.
- **String class**
    - [ ]  String 클래스는 어떤 자료형을 사용해 문자를 저장하나요?
        - char 배열을 사용해 저장합니다. 이 때 자바의 문자 인코딩 방식이 유니코드이기 때문에 배열은 한 글자당 2바이트를 가지게 됩니다.
        - String 클래스의 인스턴스가 가질 수 있는 최대 크기는 힙 메모리의 최대 크기와 동일합니다.
        - length() 메서드
            - 일반적으로는 char[] 배열의 길이를 구한 뒤 0(인스턴스 변수 corder 값)만큼 우측 시프트 연산자
            - coder가 UTF-16인 경우는 1만큼 우측 연산자
    - [ ]  String class가 final 클래스인 이유는 무엇일까요?
    - [ ]  String 클래스가 구현한 인터페이스들에 대해서 설명해수제요.
    - [ ]  String, StringBuilder, StringBuffer에 대해서 설명해주세요.
    - [ ]  왜 String 클래스에서 + 연산을 하지 말라고 할까요?
- **Annotation**
    - [ ]  어노테이션이란 무엇인지?
    - [ ]  소스코드에서 어노테이션은 어떻게 인식하는 걸까요?

---

### JVM

- [ ]  JVM이란 무엇인가요?
    - JVM이란 Class Loader System을 통해 클래스 파일들을 JVM으로 로딩합니다. 로딩된 클래스 파일들을 Execute engine이 해석하고, 해석한 프로그램들을 Runtime Data Area에 올려 실질적인 수행을 진행한다.
- [ ]  왜 GC를 수행할 때 GC 쓰레드를 제외하고 모두 멈추는 STW가 발생할까요?
    - GC의 대상이 되는 것에 힌트가 있다고 생각했습니다. GC 알고리즘은 reachability 라는 개념을 사용합니다. GC의 대상이 되는 객체가 현재 참조되고 있느냐에 대한 개념입니다.
        - static 변수
            - Java 7까지는 Method area에 있었지만
            - PermGen이 Java 8부터 Native area에 속하게 되면서
            - 현재는 Heap 영역에 위치하고 있음
        - JVM stack가 참조하는 객체
        - Java Native Method(기계어 메서드)가 참조하는 객체
    - G1 Garbage Collector?
        - JVM이 사용하는 가비지 컬렉션 알고리즘이 G1인가?
- [ ]  JIT Compiler가 캐싱하는 코드는 네이티브 메소드의 바이너리 코드인지? 까먹었다 기억이 안나
- [ ]  Garbage Collection 이란 무엇일까요? Garbage Collection 방식 중 제일 잘 알고 계시는 GC를 아무거나 하나만 설명해주세요.
- [ ]  Garbage collection 이 있는 언어를 원자력 발전소, 자동차 동력 제어, 인공위성, 국가 전력망 제어시스템 같은 곳에 쓸 수 있을까요? 후보자님의 생각을 말씀해 주세요.
- [ ]  JDK/JVM 은 대표적으로 OpenJDK 와 Oracle JDK 로 나뉘는데요, 업무에 어떤 JDK 를 사용하시겠습니까? 선택의 이유를 말씀해 주세요.
- [https://goodgid.github.io/Java-8-JVM-Metaspace/](https://goodgid.github.io/Java-8-JVM-Metaspace/)
- [https://d2.naver.com/search?keyword=garbage](https://d2.naver.com/search?keyword=garbage)
- [https://m.post.naver.com/viewer/postView.naver?volumeNo=23726161&memberNo=36733075&searchKeyword=java&searchRank=3](https://m.post.naver.com/viewer/postView.naver?volumeNo=23726161&memberNo=36733075&searchKeyword=java&searchRank=3)