# godOfJava Part 1. 대답할 수 있나요?

### 개요

단순하게 ‘아는 것’이 아닌 ‘아는 것을 설명할 수 있는 힘’을 기르기 위한 질문들과 그 답변을 준비합니다. 되도록 20초 안으로 핵심을 추출해 답변하도록 합니다.

---

### OOP, 상속

- **객체와 클래스**
    - [x]  *클래스와 객체의 차이점은 무엇일까요?*
    - 객체는 프로그래밍 기능의 분해 시 책임을 분배하기 위한 개념적인 요소라고 생각합니다. 클래스는 이러한 객체를 표현하기 위한 객체지향 언어의 도구입니다.
        - [x]  *객체의 책임이란 무엇인가요?*
        - 책임이란 자신이 담당하는 프로그램의 기능입니다. 그런 의미에서 객체지향 패러다임이란 만들어야 하는 요구사항들을 객체들에게 적절하게 나누는 과정을 통해 프로그램을 설계하는 것이라고 생각합니다.
            - [ ]  *절차적 프로그래밍과는 어떤 점이 다르며 서로 어떤 장단점이 있을까요?*
                - TODO
    - [x]  메서드와 메시지는 무엇이 다를까요?
        - 메서드는 객체가 메시지를 수신했을 때 자신의 책임을 수행하기 위해 선택하는 방법입니다. 따라서 메서드는 실제 책임을 수행하기 위한 구현 방법, 코드를 의미합니다. 반면 메시지는 객체가 소통하는 방법을 의미합니다.
    - [x]  캡슐화가 필요한 이유가 무엇일까요?
        - 객체들이 서로의 세부 구현을 모르도록 만들어 **협력의 유연함을 증가시키고, 이를 통해 변경의 파급효과를 적절하게 통제**하기 위해서입니다.
        - 객체는 서로 퍼블릭 인터페이스를 커뮤니케이션합니다. 만약 캡슐화가 되어있지 않아 세부 구현에 대해 마음대로 접근할 수 있다면 객체 사이의 결합도가 늘어나게 됩니다.
            - 예를 들어 더하기라는 기능을 구현한다고 가정하겠습니다. 더하기에는 좌변에 수를 놓기, 우변에 수를 놓기, 더하기라는 세 개의 동작이 필요합니다.
            - 만약 요청 객체가 좌변에 수를 놓기를 직접 가져다 쓴다면 나중에 좌변에 수를 놓는 동작이 변경되었을 때 그 객체도 변경되어야 합니다. 이것은 변경의 파급효과를 제어하지 못하는 것을 의미합니다.
        - 따라서 캡슐화를 통해 변경이 적고 세부 구현을 감추는 퍼블릭 인터페이스만 노출시키는 것은 협력의 유연함을 늘리고 객체 간의 결합도를 줄일 수 있는 장점을 갖고 있기 때문에 필요합니다.
- **추상화(Abstraction), 캡슐화(Encapsulation), 상속(Inheritance), 다형성(Polymorphism)**
    - [x]  Polymorphism, 다형성이란 무엇일까요?
        - 답변
            - 동일한 메시지를 수신하더라도 객체의 타입에 따라 다르게 응답할 수 있는 성질을 말합니다. 인터페이스와 다형성을 통해서 객체지향에서는 컴파일 타임의 의존성을 제어할 수 있습니다.
                - [x]  어떻게 인터페이스와 다형성을 통해 제어하는지 설명해주세요.
                - 컴파일 시점에서는 부모 클래스의 메서드인지, 자식 클래스의 메서드인지 구별하지 않고 동일한 메서드를 호출하지만 런타임에서 어떤 객체가 할당되어있는지에 따라 실행 결과가 달라집니다. 이를 통해 컴파일 타임의 의존성을 해결할 수 있습니다.
                - 정책과 구현체의 의존성 방향 모두 인터페이스를 향하게 됩니다.
    - [x]  메서드 오버로딩이란 무엇일까요? 메서드 오버라이딩이란 무엇인가요? 그리고 둘은 무엇이 다른가요?
        - 답변
            - 메서드 오버로딩이란?
                - 메서드 오버로딩이란 인자의 타입이나 수를 변경하여도 동일한 메서드 시그니처를 가지는 것을 허용해주는 기술입니다. 이를 통해 유사한 작업을 수행하는 메서드의 이름을 손쉽게 압축할 수 있습니다.
                    - 예를 들어 plus() 메서드를 구현할 때 단순한 숫자일수도, 돈일수도 있는데 이런 경우 사용이 가능합니다. 메서드 오버로딩은 컴파일 타임 시점에서 호출될 메서드의 종류를 선택하는 정적 메서드 디스패칭을 사용합니다.
            - 메서드 오버라이딩이란?
                - 부모 클래스로부터 상속받은 메서드와 동일한 시그니처의 메서드를 재정의해서 새로운 구현으로 부모 클래스의 구현을 대체하는 것을 말합니다.
                - 이를 위해 필요한 것은 부모 클래스 타입 변수에 자식 클래스 인스턴스를 할당하는 업캐스팅과 런타임 시점에 실행할 메서드를 탐색하는 다이나믹 메서드 디스패칭입니다.
                    - 다이나믹 메서드 디스패칭이 수행될 때 중요한 것은 self 참조라는 임시변수입니다. 컴파일러는 self 참조라는 임시변수를 자동으로 생성하고 메시지를 수신한 객체를 가리킵니다. 여기서 부모 클래스 방향으로 올라가며 일치하는 메시지가 존재하는지를 확인합니다.
                    - 여기서 메서드 탐색은 메서드를 찾지 못한다면 자동적으로 부모 클래스에게 메서드에 대한 책임을 위임합니다.
            
        - [오브젝트 PART 12 - 다형성](https://www.notion.so/PART-12-bdd9bdad96df48d68fefc0f564565c1f)
- **추상 클래스, 인터페이스**
    - [x]  추상 클래스와 인터페이스에 대해 설명해주세요
        - 추상 클래스는 상속 관계를 갖는 클래스들 사이에서 세부 구현을 공유해야할 필요가 있을 때, 즉 코드 재사용을 위해 사용됩니다.
        - 인터페이스는 클래스들 사이에서 객체들의 책임만 정의하고 싶을 때 사용됩니다. 인터페이스는 주로 다형성을 통해 컴파일 타임 의존성을 끊어내기 위해 주로 사용됩니다.

- **SOLID Foundation**
    - [ ]  SOLID 원칙에 대해서 설명해주세요
    - 로버트 마틴 aka 엉클밥이 명명한 객체지향에서 변경의 영향을 최소화할 수 있는 좋은 설계를 만들기 위한 원칙을 마이클 페더스가 앞글자만 따서 소개한 것입니다. 좋은 설계는 DI로 IoC 구조를 만들어서 상위 레벨 정책과 하위 레벨 구현 사이를 절연시키고 이를 통해 모듈 사이의 의존성을 적절하게 관리하는 설계라고 생각합니다. 원칙은 총 5가지로 이루어져 있는데요. 단일 책임 원칙, 확장 페쇄 원칙, 리스코프 치환 원칙, 인터페이스 분리 원칙, 의존성 역전 원칙입니다.
    - [ ]  SRP
        - 무엇인지 → SRP는 Single Responsibility Principle의 약자로 단일 책임 원칙입니다. 하나의 클래스가 하나의 책임만을 가지도록 하라는 의미입니다. 여기서 책임은 특정 클라이언트들의 묶음인 액터의 요구사항을 만족시키는 어떤 함수들의 집합, 즉 시스템의 특정 기능과 대응될 수 있습니다.
        - 어떻게 → 클라이언트의 요구사항을 기준으로 변경되는 것들을 매핑해서 분리하면 됩니다. 분리할 때는 다형성을 갖는 추상 인터페이스를 클래스와 액터 사이에 끼워넣어서 의존성의 방향을 원래는 클라이언트가 클래스를 향하던 것을 인터페이스로 바꾸고, 클래스의 의존성은 인터페이스를 향하도록 하는 방법이 있습니다.
        - 어떤 장점? → 하나의 클래스가 여러 개의 책임을 갖는 경우 메서드의 성질이 각 책임마다 상이할 가능성이 높습니다. 따라서 자연스럽게 응집도가 낮고 여러 클라이언트 객체와 의존 관계를 맺게 됩니다. 그 결과는 변경의 파급효과에 예민해지고 재사용도 힘들어지는 문제점을 갖게 됩니다. 반대로 SRP를 지켰을 때는 높은 응집도와 낮은 결합도를 가지며 재사용까지 가능해집니다.
    - [ ]  OCP
        - 무엇인지 → OCP는 Open-Closed Priniciple의 약자입니다. 저는 Open, closed 앞에 목적어가 하나씩 생략되어 있다고 생각합니다. Open은 새로운 타입 추가를 통한 기능의 추가가, Closed에는 상위 레벨 정책의 수정이 숨겨져 있습니다. 풀어서 다시 말하자면 OCP는 타입 추가로 인한의 기능의 확장에 열려있고 Closed는 상위 레벨의 정책 변경에는 닫혀있도록 해야한다는 원칙인 것이죠.
        - 어떻게 → 이것은 다형성과 추상화 메커니즘을 활용해 지킬 수 있습니다. 자바에서는 추상 인터페이스를 사용할 수 있는데요. 변경되는 것과 변경되지 않는 것을 구별하고 이 둘이 만나는 지점에 인터페이스를 도입하면 됩니다.
        - 어떤 장점 → 이를 통해서 코드에 손을 대지 않고도 기능을 확장할 수 있으며 상위 정책도 건드리지 않을 수 있다는 명확한 장점이 있습니다.
        - 한계점 → 하지만 OCP를 완벽하게 지키기에는 어려운 점이 명확합니다. 만약 고객이 설계 과정에서 고려되지 않았던 새로운 기능을 요구하면 대책이 없어진다는 문제가 존재합니다. 즉 미래를 예측할 수 없기 때문에 아무리 설계에서 고민해봐도 결국 고객은 예상치 못한 기능의 추가,변경을 원하는 것이죠. 이를 해결하기 위해서 처음부터 치밀하게 설계하는 Big Desiun Up Front 혹은 미리 예상하지 말고 고객의 요구사항에만 빠르게 대응하는 Agile 디자인이 있습니다.
    - [ ]  LSP
        - 무엇인지 → LSP는 리스코프 치환 원칙이며 클라이언트가 만약 상속 구조를 갖는 객체라면 정확한 타입을 모른 채 사용해도 문제가 없어야 한다는 것입니다.
        - 어떻게 → 이를 가능하기 위해선 기반 클래스가 갖고 있는 규약을 하위 클래스가 반드시 지켜야합니다.
        - 어떤 장점 → 그리고 리스코프 치환 원칙은 앞서 얘기한 확장을 가능케 하는 OCP가 완성되기 위한 조건이라고 생각합니다. LSP 원칙을 지키게 되면 상위 타입의 어떤 구현체가 들어와도 정상 동작을 보장하게 됩니다. 따라서 우리는 OCP에서 추상 인터페이스만 믿고 있어도 정상 작동하는 것입니다.
        - 한계점 → 이 때 주의해야할 것이 있는데 상속을 결정하게 되는 기준인 is-a 관계를 생각할 때 클라이언트가 그것을 어떻게 바라보는지를 기준으로 삼아야 한다는 것입니다. 흔히 예시로 삼는 정사각형-사각형 예시는 전형적인 위반 사례인데요. 이것은 클라이언트가 직사각형과 정사각형을 동일하게 바라본다는 가정 하에서만 가능합니다. 하지만 대부분은 정사각형이 직사각형이긴 하지만 정사각형은 가로 세로가 똑같고, 직사각형은 똑같을수도 있지만 다를수도 있잖아? 라고 얘기합니다. 따라서 이는 LSP를 위반한 사례가 되는거죠.
    - [ ]  ISP
        - 무엇인지 → Interface Segregation Principle의 약자로 한 명의 클라이언트, 액터에게만 집중해야 한다는 의미입니다. 예를 들어가 제가 제공하는 기능이 100개가 있을 때 A 클라이언트가 30개, B가 30개를 사용하고 나머지가 쭉쭉 나가면, 이 때 사용하는 기능만 제공하도록 인터페이스를 분리해야한다는 원칙입니다.
        - 어떻게 → 책임을 구분하고 여러 개의 인터페이스를 생성해서 분리하면 됩니다.
        - 어떤 장점 → 이렇게 많은 클라이언트에게 기능을 제공하게 되면  나를 의존하는 클라이언트들이 많아져 결합도가 높아집니다. 이 때는 호출되는 메서드들을 묶는 추상 인터페이스로 추출하고 의존성을 주입받도록 바꾸면 문제를 해결할 수 있습니다.
    - [ ]  DIP
        - 무엇인지 → Dependency Injection Principle의 약자로써 상위 모듈이 하위 레벨의 변경에 대해 파급효과를 받게 되는 의존성을 끊어야 한다는 원칙입니다. 위에서 얘기한 원칙들의 근본이 되는 원칙이라고 생각합니다.
        - 어떻게 → 추상 인터페이스를 상위 모듈과 하위 모듈의 사이에 끼워넣어 둘의 의존성 방향이 추상 인터페이스를 향하도록 하면 됩니다.
        - 어떤 장점 → 이를 통해 자연스럽게 하위 모듈의 구현체들은 확장성을 갖게 됩니다. 물론 추상 인터페이스에서 원하는, 즉 클라이언트가 요구하는 기능은 완벽하게 구현을 하는, LSP 원칙을 만족해야겠죠. 또한 컴파일 타임 시점에서 상위 모듈이 하위 모듈에게 직접 구속받지 않고 느슨한 결합도를 유지할 수도 있습니다.

---

### Java

> ***Part 1***
> 
- **자료형**
    - [x]  기본 자료형과 참조 자료형이 메모리 상에서 저장되는 위치는 어디일까요?
        - 두 데이터 모두 JVM 내부의 Runtime data area에 저장됩니다. 그 중 기본 자료형은 각 쓰레드의 고유한 스택 공간에 스택 프레임 형태로 저장됩니다. 참조 자료형은 Heap 영역에 저장됩니다. 만약 String 클래스라면 Heap 영역 중 String Constant Pool에 저장됩니다.
        - [x]  스택 프레임은 어떤 구조로 이루어져 있나요?
            - 스택 프레임은 메서드의 지역 변수를 저장하는 Local Variable Section, 연산에 이용되는 데이터 및 결과를 저장하는 Operand Stack, Frame Data로 이루어져 있습니다.
            - 최상단 스택 프레임을 current frame이라고 부릅니다.
                - Local Variable Section는 0-Base 배열로 구성되어있고 로컬 변수와 메서드 파라미터가 저장됩니다.
                - Operand Stack에는 연산에 사용되는 값들이 저장됩니다.
                - Frame Data에는 다른 클래스를 참조하거나 메서드를 수행할 때 Constant Pool Resolution, Normal Method Return, Exception Dispatch가 있습니다.
    - [x]  (설로인) 컴퓨터는 소숫점 계산을 잘 못합니다. 그 이유가 무엇일까요? 어떻게 문제를 해결할 수 있을까요? 직접 구현한다면 어떻게 하시겠습니까?
        - 이유는 부동 소수점을 표현하기 위한 IEEE 754를 사용합니다.
            - [x]  *왜 IEEE 754 기술을 사용할까요?*
            - 고정 소수점은 정수부와 소수부의 크기를 제한합니다. 즉 비트를 효율적으로 사용하지 못하는 것이죠. 따라서 과학적 표기법을 통해 유효한 숫자만 표시할 수 있도록 하기 위해 부동 소수점 방식을 사용합니다.
            - 그리고 이렇게 소수점을 소수부의 가장 첫번째 자리까지 당겨오는 것을 정규화라고 합니다.
        - 하지만 부동 소수점은 가수의 자리수를 32비트에서는 23자리, 64비트에서는 52자리로 제한하기 때문에 표현하고자 하는 소수부의 이진법 표기가 무한소수로 표기되는 경우 결국 일부분을 잘라낼 수 밖에 없게 됩니다. 이 때문에 값의 오차가 발생합니다.
            - [x]  *32비트에서 64비트로 올라가면 정밀도가 향상됩니다. 정밀도란 무엇일까요?*
                - 말 그대로 숫자의 오차를 줄이는 법이라고 생각합니다. 위에서 말했듯 비트 크기의 한계 때문에 결국 일부분이 끊기는데, 비트 크기가 크다면 최대한 잘리는 비트의 수가 적어질 것이고 실제값에 더 가까워질 수 있습니다.
        - [x]  *자바에서 BigDecimal은 어떻게 이런 문제를 해결할까요?*
            - 수를 내부적으로 10진수로 저장합니다. 부동소수점에서 문제가 되는 부분는 가수를 2진수로 표현하려 했기 때문이었습니다. 하지만 10진수로 표현한다면 위 오차를 없앨 수 있습니다.
    - [ ]  pass by value, pass by reference에 대해서 설명해주세요
        - 메서드의 매개변수가 전달될 때 인자의 자료형에 따라 ‘값' 혹은 ‘주소’가 전달되는 것을 말합니다. 인자가 프리미티브 타입인 경우는 **복사된 값만 전달**됩니다. 즉 원본에 영향을 끼칠 수 없습니다. 반면 참조형 객체는 ‘주소'가 전달되기 때문에 만약 메서드 내부에서 해당 인스턴스의 상태에 수정을 시도하는 경우 원본에 영향이 미치게 됩니다. 만약 내부에서 다른 객체로 대체하는 경우는 영향을 받지 않는다.
            - [ ]  복사된 값만 전달된다는 것을 JVM의 스택 프레임과 연관지어 설명해주세요
            - JVM의 Runtime data area에는 각 쓰레드별로 상태값을 저장하기 위한JVM Stack이 생성됩니다.
            - JVM Stack Area는 공유되지 않는 영역으로 메서드가 호출될 때마다 Stack Frame이라는 자료구조가 스택 영역에 적재됩니다. 해당 값들은 Stack Frame의 Local Variable에 값이 올라가거나 메모리 주소가 올라가게 됩니다.
- **형 변환**
    - [ ]  auto boxing, unboxing 이란 무엇인가요?
    - Wrapper 클래스와 primitive 사이에서 서로간 캐스팅을 해주는 것을 말합니다.
    - 프리미티브 타입 값이 래퍼 타입으로 선언된 파라미터를 통과할 때
        - 어떻게 가능하냐?
    - [ ]  업캐스팅과 다운캐스팅
    - [x]  auto boxing, unboxing 이란 무엇인가요?
    - Wrapper 클래스와 primitive 타입사이에서 메서드의 파라미터를 통과할 때와 변수로 할당될 때 서로간 캐스팅을 해주는 것을 말합니다. 주로 기본 타입을 담을 수 없는 컬렉션에서 많이 사용됩니다.
        - [x]  Wrapper Class란 무엇인가요?
            - 말 그대로 객체 형태가 되도록 한번 감싼 형태의 클래스를 말합니다. JDK가 제공하는 래퍼 클래스들은 **인스턴스 풀링**을 제공합니다. 따라서 각 래퍼 클래스들은 캐시 형태로 자주, 일반적으로 사용되는 인스턴스들의 목록을 저장해놓고 필요할 때마다 사용하는 방식을 취합니다.
            - 예를 들어 Integer class에서는 IntegerCache라는 정적 이너 클래스를 갖고 있습니다. 이 클래스는 맨 처음 사용될 때만 초기화됩니다. 비록 캐시를 생성하는 것때문에 처음에는 시간이 조금 걸리지만, 후에는 **메모리를 재사용**한다는 장점을 갖고 있습니다. 하지만 new 연산자를 사용하는 경우 이 캐싱이 적용되지 않습니다. 이 경우는 리소스 풀이 아닌 힙 영역에 생성되며, Integer.valueOf() 혹은 기본값 타입을 할당하는 경우만 캐싱이 적용됩니다.
            - 즉 내부 캐시를 사용하기 위해선 항상 기본 할당을 사용하여 변수를 참조하거나 valueOf() 메서드를 사용해야 합니다. 캐싱의 기본값은 -128~127이며 이 사이의 값이 들어온 경우 미리 생성되어 캐싱된 인스턴스를 반환합니다. 만약 런타임에 사용하는 값들이 디폴트 설정보다 크다면 runtime args 설정이나 JVM 옵션을 통해 조정이 가능합니다.
                
                ```java
                - -Djava.lang.Integer.IntegerCache.high=<size>
                - -XX:AutoBoxCacheMax=<size>
                ```
                
            - [x]  인스턴스 풀링이 무엇인가요?
                - 자바에서는 대부분 new 생성자를 통해서 클래스 인스턴스를 초기화합니다. 이 인스턴스들은 heap 영역에 생성되고 이건 대부분 무거운 작업으로 고려됩니다. 따라서 대부분의 프레임워크에서는 이를 해결하기 위해 **리소스 풀링**이라는 방법을 사용합니다. Persistence framework에서는 커넥션 풀을, 자바에서는 String Pool 개념을 사용합니다. 우린 이 목적을 위해 **프로토타입 패턴**을 사용합니다. 미리 만들어진 객체를 사용하는 것은 굉장히 큰 도움이 됩니다.
    - [x]  업캐스팅과 다운캐스팅
        - 자식(하위) 클래스에서 부모(상위) 클래스로 캐스팅되는 것을 업캐스팅, 반대를 다운캐스팅이라고 합니다. 이를 사용하는 이유는 객체지향의 다형성 메커니즘과 연관되어 있습니다. 다형성이란 간단하게는 추상 인터페이스에 대해 서로 다른 구현을 연결할 수 있는 성질인데요. 업캐스팅을 통해 자식 클래스가 부모 클래스의 메서드를 사용할 수 있습니다.
- **static**
    - [ ]  static 변수, static 메서드는 일반 인스턴스 변수, 인스턴스 메서드와 어떤 점이 다른가요?
    - [x]  스태틱 변수는 JVM 런타임 메모리 중 어디에 올라가나요?
        - Java 7까지는 Method area에 있었지만 PermGen이 Java 8부터 Native area에 속하게 되면서 현재는 Heap 영역에 위치하고 있습니다.
- **Object Class**
    - [ ]  Object가 지원하는 `hashcode(`, `equals()` 메서드에 대해서 설명해주세요.
        - 무엇인지 → `equals()` 메서드는 객체의 동등성을 체크하기 위한 메서드입니다. 하지만 컴퓨터는 우리가 인지하는 ‘같다'라는 개념을 기본적으로 인스턴스의 메모리 주소값을 통해 비교합니다. 이 때 인스턴스의 메모리 주소값을 16진수로 표현한 int 타입으로 리턴하는 메서드가 `hashcode()`입니다.
        - 왜 필요한지 → 예를 들어 대한민국 국민이라는 객체를 표현한다고 가정해보겠습니다. 이 때 주민등록번호가 같다면 우린 같다고 인지합니다. 하지만 동일한 주민등록번호를 가진 인스턴스가 n개가 올라갔을 때 해당 인스턴스들은 모두 다른 메모리 주소를 가질 것입니다. 그렇다면 컴퓨터는 우리가 관념적으로는 같다고 인지함에도 불구하고 다르다는 결과를 뱉을 것입니다. 따라서 같다라는 개념을 정의하는 것은 굉장히 중요합니다.
        - 어떤 예시가 있는지 → 만약 같다라는 개념을 제대로 정의하지 못한다면 Map 자료구조의 자료 입출력 혹은 데이터베이스에서 자료를 조회할 때 혹은 메모리 캐시를 제대로 사용할 수 없습니다. 이런 문제점들은 Hibernate에서는 @Entity의 @Id를 통해서, Java에서는 record 키워드를 통해 혹은 직접 구현해 해결할 수 있습니다.
        - [Java hashCode() and equals()](https://howtodoinjava.com/java/basics/java-hashcode-equals-methods/)
- **Enum Class**
    - [x]  Enum 클래스가 무엇인가요?
        - 무엇인지 → 클래스의 모양을 띤 상수입니다. JDK 1.5부터 추가됐습니다. 이전에는 public static final 형태 혹은 인터페이스의 변수로 많이 지정이 되었었습니다. 현재 근무하는 곳에서도 이런 형태를 띄고 있어 Enum 클래스로 마이그레이션하는 작업을 진행하는 경우가 많습니다.
        - 어떻게 → 생성자를 private로 만들고 컴파일 타임에 모든 값을 알고 있는 형태로 만들어야 합니다. 이를 통해 타입 안정성을 보장할 수 있습니다.
    - [x]  상속이 가능할까요?
        - enum클래스는 내부적으로 Enum<T>를 상속받습니다. 따라서 다른 클래스를 extend 할 수 없습니다. 이펙티브 자바에서는 이런 enum의 기능을 계승해서 사용하고 싶다면 interface를 생성 + 구현하여 사용하는 방식을 권장합니다.
- **final keyword**
    - [ ]  자바에서 final 키워드는 어떤 역할을 하나요?
        - 무엇인지 → 데이터를 재할당하는 것을 막아주는 키워드입니다. 기본형의 경우 해당 키워드를 통해 불변 객체가 될 수 있지만 참조형 객체의 경우 그렇지 않습니다.
        - 어떻게 → 만약 참조형 객체를 불변 클래스로 만들고 싶다면 아래와 같은 방법을 따르면 됩니다. 클래스, 내부 인스턴스 필드를 모두 final로 선언해줍니다. 생성자는 private으로 유지하고 정적 팩토리 메서드를 제공합니다. 만약 컬렉션 프레임워크의 List처럼 메모리 참조값이 유출되는 변수가 있다면 Collections.unmodifiableList() 메서드와 같은 방어적 복사를 사용해서 전달하면 됩니다.
        - 어떤 장점 → 값의 변경으로 인한 사이드 이펙트를 원천 차단할 수 있습니다. 멀티쓰레드 환경에서 공유 자원에 대한 걱정을 없앨 수 있습니다. 또한 보안 관점에서도 유용합니다. 시스템 내부에서 값의 변경될 걱정없이 민감한 정보를 읽기 전용으로 만들 수 있습니다. String 클래스가 이에 해당됩니다. 또한 단일 인스턴스를 지정하여 중복 항목을 공유할 수도 있습니다. 자바에서는 java 16부터 record 키워드를 통해 불변 객체를 지원합니다.
- **Exception**
    - [ ]  예외 종류에 대해 설명해주세요.
        - 무엇인지 → 자바에서 예외는 Error, Exception으로 나눠져 있으며 발생의 근원지에 따라 명칭이 달라집니다. Error는 자바 프로그램 밖에서 발생한 예외로 주로 JVM에서 발생시키고 **자바 프로세스**에 영향을 줍니다. Error는 애플리케이션에서 크게 핸들링에 신경 쓸 필요는 없습니다. Exception은 프로그램 안에서 발생합니다. 즉 프로그램을 실행시키는 쓰레드에서 발생합니다.
        - 특징 → Exception은 Checked Excepton과 Runtime Exception으로 나눠집니다. Checked Excepton은 컴파일 시점에서 try/catch 구문 혹은 throws 키워드를 통해 명시적으로 자원의 복구를 위한 별도의 로직을 명시해주어야 합니다. 하지만 이 과정에서 자원을 제대로 반납하지 않는 문제들 때문에 java 7부터는 try-with-resource를 통해 사용한 리소스를 자동으로 반환해줍니다.
        - 반면 Unchecked Exception은 런타임에서 발생하기 때문에 물론 별도의 로직이 필요하긴 하지만 컴파일 타임처럼 명시적으로 필요하진 않습니다. 초기 자바에는 대부분의 예외가 체크 예외였습니다.하지만 최근에는 예외처리를 강제하는 점때문에 발생하는 예외 블랙홀 혹은 무책임한 throw문때문에 가능한 런타임 예외로 만드는 경향이 있습니다.
        - [ ]  try-with-resource 에 대해서 설명해주세요.
            - Java 7부터 지원하는 기능으로써 try-catch-finally 구문에서 개발자들이 자원을 반환하지 않는 휴먼 에러를 방지하기 위해 등장한 기능입니다. AutoCloseable 인터페이스를 구현하는 경우 try-with-resource 블록을 벗어날 때 예외 발생 여부와 상관없이 자원이 자동으로 반환됩니다. try-catch 문과의 차이점은 try() 블록의 자원을 명시해야한다는 점입니다. Java 9부터는 try 문 외부에서 객체를 선언하고 try() 블록의 변수에 할당하는 식으로 변경됐습니다.
- **String class**
    - [ ]  String 클래스는 어떤 자료형을 사용해 문자를 저장하나요?
        - Java 8까지의 char형은 UTF-16기반의 2byte를 참조했습니다. 따라서 영어를 사용하더라도 기본적으로 2byte를 사용했죠. 하지만 Java 9부터는 문자열에 따라 Latin-1(1byte)와 UTF-16(2byte)로 나누어지며, byte 배열을 사용해 저장하도록 변경됐습니다. 이 때문에 Java 9부터는 char 연산을 수행하는 클래스가 StringLatin1 class와 StringUTF16 클래스로 나눠지게 됐습니다. 관련 내용은 JEP 254에 명시된 Compact String 자료를 통해 확인할 수 있습니다.
        - `StringUTF16` 와 `StringLatin1` 의 `hashcode(byte[] value)` 구현 차이
            
            ```java
            // StringUTF16
            public static int hashCode(byte[] value) {
                int h = 0;
                int length = value.length >> 1;
                for (int i = 0; i < length; i++) {
                    h = 31 * h + getChar(value, i);
                }
                return h;
            }
            
            // StringLatin1
            public static int hashCode(byte[] value) {
                int h = 0;
                for (byte v : value) {
                    h = 31 * h + (v & 0xff);
                }
                return h;
            }
            ```
            
            - StringLatin1에서 byte에 0xff을 AND 연산하는 이유는 무엇일까요?
                - 양수를 보장하기 위해서? 근데 왜 h값이 21억을 넘어가도 오버플로우가 발생을 안하고 음수로 떨어지는 걸까?
            - byte를 양수로 표현하고 싶다면 int타입의 0xff를 AND 연산하여 byte 앞의 1을 0xff의 0과 AND 연산시켜 양수로 바꿉니다.
            - String은 인스턴스 필드를 통해 hashcode를 캐싱합니다.
                
                ```java
                private int hash; // Default to 0
                ```
                
        - 이것의 계기는 JVM 내부의 힙 메모리의 대부분을 String 자료형이 사용하며 대부분 영어로 작성되어 있기 때문에 굳이 UTF-16을 사용해 1바이트를 낭비하지말자는 것입니다. Java 9부터 새롭게 생성되는 String 클래스는 문자열의 내용에 따라 ISO-8859-1/Latin-1(문자당 1바이트) 또는 UTF-16(문자당 2바이트)으로 인코딩된 문자를 저장합니다. String 클래스는 이를 저장하기 위해 `coder`와  *`COMPACT_STRINGS`* 인스턴스 변수를 통해 갖고 있습니다.
        - String 클래스의 인스턴스가 가질 수 있는 최대 크기는 힙 메모리의 최대 크기와 동일합니다. length() 메서드는 일반적으로는 char[] 배열의 길이를 구한 뒤 0(인스턴스 변수 corder 값)만큼 우측 시프트 연산자를 취합니다. 만약 coder가 UTF-16인 경우는 1만큼 우측 연산자를 취합니다.
    - [ ]  String class가 final 클래스인 이유는 무엇일까요?
    - [ ]  String 클래스가 구현한 인터페이스들에 대해서 설명해수제요.
        - String pool, 보안 이슈, 메모리 캐시, 멀티스레딩
            - **String pool**
                - 사실 개발자들은 자바를 디자인할 때부터 String 클래스 프로그램에서 굉장히 많이 쓰여질 것이라고 예측했습니다. 따라서 설계 단계부터 최적화를 시키고자 노력했습니다. 그리고 최적화의 핵심으로 떠오른 방법이 바로 String Constant Pool이었습니다.
                    - String 객체를 생성하여 공유하는 방법을 통해 매번 객체가 생성되고 소멸되는 자원을 줄였습니다.
                    - 공유라는 행위는 같은 것을 나눠쓴다는 것을 의미합니다. 한정된 자원을 나눠씀으로써 자원을 효율적으로 사용할 수 있습니다.
                        - 하지만 우리가 도서관에서 책을 대여해서 보고있는데 누군가가 책을 찢어간 경우 역시 심심찮게 있을 겁니다. 즉 공유는 자원을 효율적으로 사용한다는 장점과 변경에 예민하다는 단점을 동시에 갖습니다.
                        - 따라서 String은 이런 책의 훼손같은 단점을 극복하기 위해 책이 변하지 않도록 코팅해버린 것입니다.
                - String Literal은 매번 인스턴스가 생성되지 않고 한번 생성된 후 상수 풀에 저장되어 참조됩니다. 만약 String이 변경 가능하다면 어떤 일이 벌어질까요?
                    
                    ```java
                    String a = "Test";
                    String b = "Test";
                    b = b.toUppderCase();
                    ```
                    
                - 이렇게 데이터를 변경된다면 어떤 일이 일어날까요? **a뿐만 아니라 동일한 애플리케이션 내에 Test를 참조하는 모든 변수가 TEST로 변경**됩니다. 이는 프로그램 내에서 치명적인 오류를 발생시킬 것이 틀림없습니다.
                - String 클래스가 불변인 것과 상수 풀을 사용하는 것은 이렇듯 상호 보완적인 관계에 있습니다. 불변이지 않으면 상수 풀을 사용할 수 없고, 상수 풀을 사용하더라도 불변이지 않으면 문제가 발생하죠.
            - **Security**
                - String이 불변 객체인 이유 중 핵심은 바로 **보안**입니다. 자바는 모든 서비스 수준에서 안전한 환경을 제공하겠다는 분명한 목표를 갖습니다. 이 목표를 지키기 위한 보안 영역에서 String 클래스는 굉장히 중요한 역할을 합니다.
                - 많은 자바 클래스 내에서 String 타입의 파라미터가 사용됩니다.
                    - 네트워크 커넥션을 맺을 때 호스트 이름이나 포트 번호 등과 같은 정보들을 String 인자로 넘깁니다.
                    - 데이터베이스 커넥션을 맺을 때 데이터베이스 URL, 호스트, 비밀번호 정보도 String 인자로 넘깁니다.
                    - File I/O에서 디렉토리의 패스와 파일명 역시 String 인자로 넘깁니다.
                - 만약 String이 불변 객체가 아니라면 위 케이스들에서 치명적인 보안 문제가 발생합니다.
                    - 예를 들어 사용자가 시스템의 특정 파일에 접근할 수 있는 권한을 받았다고 가정하겠습니다. 이 때 String이 변경 가능하다면 권한을 가진 채로 경로를 변경해 접근해버릴지도 모릅니다. 이는 중대한 보안 문제를 일으킵니다.
                    - 네트워크, 데이터베이스와 같은 시스템 연결에서도 문자열 값의 변경은 이러한 보안 위협을 발생시킵니다. 변경 가능한 String 클래스는 String 타입의 매개인자를 사용하는 Reflection에서도 보안의 영향을 끼칠 수 있습니다.
            - **Use of String in Class Loading Mechanism**
                - String 클래스는 클래스 로딩 메커니즘 안에서도 많이 사용됩니다. 만약 String이 변경 가능하다면 클래스 로딩 시점에 악의적으로 로드되는 클래스명을 변경할 수 있습니다. 예를 들면 java.io.Reader를 com.unknown.DataStolenReader처럼 말이죠. String 클래스를 불변으로 만드는 것을 통해 우린 JVM이 올바른 클래스를 로드하는지에 대해 걱정하지 않아도 됩니다.
            - ****Multithreading Benefits****
                - 자바에서 동시성 및 멀티스레딩은 핵심 중에 핵심입니다. 따라서 String 객체를 멀티스레딩 환경에서 어떻게 보호할 수 있는지 꼭 필요한 연구과제였습니다. String 클래스는 앞서 말했듯 설계 단계부터 사용빈도가 아주 높을 것으로 예상되었습니다. 따라서 차라리 애초에 불변으로 만들어 동기화에 대한 이슈를 걱정하지 않고 사용하도록 만들었습니다.
                    - 불변이라는 간단한 특징 하나로 자연스럽게 읽기만 가능하다는 특징을 가지기 때문에 복잡하고 오류가 발생하기 쉬운 동시성 코드들이 훨씬 쉬워집니다.
            - ****Optimization and Performance(Caching)****
                - String 클래스는 불변임을 보장하기 때문에 hashcode() 메서드가 호출될 경우 해당 값을 캐싱해놓았다가 반환합니다.
                - 이는 String이 Hashtable, HashMap과 같은 해시 기반 컬렉션에서 키로 사용될 때 성능의 향상을 가능케 합니다.
                    - HashMap의 키가 무조건 불변해야한다는 제약사항은 없지만 키가 변경 가능한 객쳋인 것보다 훨씬 안전하게 사용할 수 있습니다.
                    - 해시 기반 컬렉션 내부에 저장될 때 상태가 변경될 위험 역시 없습니다.
    - [ ]  String, StringBuilder, StringBuffer에 대해서 설명해주세요.
        - StringBuilder는 불변 객체인 String과는 다르게 가변 객체입니다. StringBuffer는 동기화를 보장합니다.
    - [ ]  왜 String 클래스에서 + 연산을 하지 말라고 할까요?
- **Annotation**
    - [ ]  어노테이션이란 무엇인지?
    - [ ]  소스코드에서 어노테이션은 어떻게 인식하는 걸까요?

---

### JVM

- [ ]  JVM이란 무엇인가요?
    - JVM이란 Class Loader System을 통해 클래스 파일들을 JVM으로 로딩합니다. 로딩된 클래스 파일들을 Execute engine이 해석하고, 해석한 프로그램들을 Runtime Data Area에 올려 실질적인 수행을 진행한다.
- [ ]  왜 GC를 수행할 때 GC 쓰레드를 제외하고 모두 멈추는 STW가 발생할까요?
    - GC의 대상이 되는 것에 힌트가 있다고 생각했습니다. GC 알고리즘은 reachability 라는 개념을 사용합니다. GC의 대상이 되는 객체가 현재 참조되고 있느냐에 대한 개념입니다.
        - static 변수
            - Java 7까지는 Method area에 있었지만
            - PermGen이 Java 8부터 Native area에 속하게 되면서
            - 현재는 Heap 영역에 위치하고 있음
        - JVM stack가 참조하는 객체
        - Java Native Method(기계어 메서드)가 참조하는 객체
    - G1 Garbage Collector?
        - JVM이 사용하는 가비지 컬렉션 알고리즘이 G1인가?
- [ ]  JIT Compiler가 캐싱하는 코드는 네이티브 메소드의 바이너리 코드인지? 까먹었다 기억이 안나
- [ ]  Garbage Collection 이란 무엇일까요? Garbage Collection 방식 중 제일 잘 알고 계시는 GC를 아무거나 하나만 설명해주세요.
- [ ]  Garbage collection 이 있는 언어를 원자력 발전소, 자동차 동력 제어, 인공위성, 국가 전력망 제어시스템 같은 곳에 쓸 수 있을까요? 후보자님의 생각을 말씀해 주세요.
- [ ]  JDK/JVM 은 대표적으로 OpenJDK 와 Oracle JDK 로 나뉘는데요, 업무에 어떤 JDK 를 사용하시겠습니까? 선택의 이유를 말씀해 주세요.
- [https://goodgid.github.io/Java-8-JVM-Metaspace/](https://goodgid.github.io/Java-8-JVM-Metaspace/)
- [https://d2.naver.com/search?keyword=garbage](https://d2.naver.com/search?keyword=garbage)
- [https://m.post.naver.com/viewer/postView.naver?volumeNo=23726161&memberNo=36733075&searchKeyword=java&searchRank=3](https://m.post.naver.com/viewer/postView.naver?volumeNo=23726161&memberNo=36733075&searchKeyword=java&searchRank=3)