# Part 24: 자바랭 다음으로 많이 쓰는 애들은 컬렉션 (3)

### 개요

컬렉션 프레임워크 중 Map에 대해서 알아봅니다.

---

### Map이란?

- 자바에서 Map은 아래와 같은 특성을 갖는 자료구조입니다.
    - 모든 데이터는 키와 값이 반드시 존재해야 합니다.
    - 키가 없이 값만 저장될 수는 없습니다.
    - 그 반대의 경우 값 없이 키만 저장할 수도 없습니다.
    - 키는 Map 내부에서 단 하나만 존재하는 고유한 값이어야 합니다.
    - 반면 값은 중복되어도 상관없다.
- Map 인터페이스를 구현한 클래스는 대표적으로 HashMap, TreeMap, LinkedHashMap, Hashtable이 있습니다. Hashtable은 다른 3개의 구현체와 조금 다른 아래와 같은 특징을 갖습니다.
    - Map은 컬렉션 뷰(Collection View)를 사용하지만 Hashtable은 Enumeration 객체를 통해서 데이터를 처리합니다.
        - 컬렉션 뷰는 말 그대로 컬렉션 내부를 보여주는 기능입니다. Map에서는 `keySet()`, `values()`, `entrySet()` 를 제공해 컬렉션 내부를 확인할 수 있습니다.
    - Map은 키, 값, 키-값 쌍으로 데이터를 순환하며 처리할 수 있지만, Hashtable은 키, 값만 가능합니다.
    - Map은 이터레이션 처리 중 데이터를 안전하게 삭제할 수 있는 방법을 제공합니다. 하지만 Hashtable은 그렇지 않습니다.
    - 이 중 HashMap과는 몇 가지 다른 점이 존재합니다.
        - HashMap은 키, 값에 null을 저장할 수 있지만, Hashtable은 그렇지 않습니다.
        - 반면 Hashtable은 쓰레드 세이프하지만 HashMap은 그렇지 않습니다. 만약 HashMap을 쓰레드 세이프하게 사용하기 위해선 `Collections.synchronizedMap()` 을 사용해야 합니다.

---

### HashMap 클래스에 대해서

- HashMap은 Map 인터페이스를 구현하고 AbstractMap 추상 클래스를 확장한 구현체입니다.
- 일반적으로 HashMap 객체를 생성할 때 기본 생성자를 사용합니다. 하지만 만약 저장해야될 데이터의 갯수가 많다면 초기 크기를 지정해주는 것이 권장됩니다.
    - HashMap 객체는 일반적으로 기본 생성자를 통해 생성되며 16개의 저장공간과 0.75의 로드 팩터를 갖습니다. 만약 담아야 할 데이터가 많다면 초기 크기를 지정해주는 것이 좋습니다. 그 이유는 HashMap 내부에 데이터를 담는 공간인 **버킷 bucket**과 관련이 있습니다.
        - 버킷은 쉽게 말하자면 n개의 저장공간을 갖는 배열입니다.
        - 버킷은 로드 팩터가 저장된 데이터의 갯수/capacity의 값과 같아질 때 2배로 커집니다.
    - 자바 HashMap에서는 `x.hashCode() % n` 연산식을 통해 저장될 버킷의 위치를 정합니다.
        - 위 연산식은 저장하고자 하는 데이터(x)의 해시코드를 N(저장공간의 크기)로 나눈 결과값을 의미합니다.
        - 만약 연산식의 결과값이 같다면 여러 개의 노드가 LinkedList 형태로 저장되는 Seperate Chaning 방식으로 데이터를 저장합니다.
        - 위 연산식으로 버킷을 지정하게 되면 서로 다른 해시코드를 갖는 객체가 같은 버킷에 저장될 확률이 1/M이 됩니다. 예를 들어 데이터 그대로 해시코드를 사용하는 Integer클래스는 17과 34가 다른 해시코드를 가짐에도 같은 버킷에 저장되게 됩니다.
    - 데이터를 검색할 때 사용되는 get()은 해시 버킷에 값이 여러 개일 경우 equals() 메서드를 호출해 동일한 값을 탐색하는 과정을 거칩니다.
        - 그런데 여기서 함정이 하나 있습니다. 만약 저장된 데이터가 8개라면 로드 팩터는 0.5입니다. 하나의 버킷에 약 1개의 데이터도 차있지 않죠. 그러니 접근할 때 equals()를 수행할 필요가 없습니다. 데이터가 하나만 있을테니까요. 과연 맞을까요?
        - 만약 하나의 버킷에 6개의 데이터가 몰려있다면 어떨까요. 이런 경우는 흔치 않겠지만 이 때 검색 성능은 굉장히 떨어지게 됩니다. 따라서 이를 방지하기 위한 이상적인 값 **0.75**를 지정해놓은 것입니다.
- 각 내용들에 대한 자세한 내용은 하단의 **'조금 더 자세히 HashMap 클래스에 대해’**에서 확인해보겠습니다.

---

### 정렬된 키의 목록을 원한다면 TreeMap

- HashMap과 Hashtable은 순서가 없습니다. 하지만 우린 순서가 필요한 키-값 쌍의 자료구조 역시 필요합니다. 이 때는 TreeMap 클래스를 사용할 수 있습니다.
    - TreeMap은 데이터를 저장하며 키를 정렬합니다. 정렬되는 순서는 String의 경우 숫자 → 알파벳 대문자 → 알파벳 소문자 → 한글 입니다.
    - 이러한 키 정렬이 가능한 이유는 SortedMap 인터페이스를 구현했기 때문입니다.
        - 맨 앞, 맨 뒤의 키, 특정 키의 앞뒤에 있는 키를 검색할 수 있는 메서드가 제공됩니다.

---

### [Naver D2: **Java HashMap은 어떻게 동작하는가?**](https://d2.naver.com/helloworld/831311)

- Map이란 ‘키에 대한 해시 값을 사용하여 값을 저장하고 조회하며, 키-값 쌍의 개수에 따라 동적으로 크기가 증가하는 associate array’를 부르는 용어 중 하나입니다. HashMap, HashTable도 이에 포함되며 다른 용어로는 Map, Dictionary, Symbol Table이 있습니다.
- HashMap은 보조 해시 함수(Additional Hash Function)를 사용하지만, HashTable은 보조 해시 함수를 사용하지 않습니다. 따라서 보조 함수를 통해 해시 충돌(hash collision)의 빈도를 낮출 수 있는 HashMap이 상대적으로 성능상 이점이 있습니다.
- 키-값 쌍 데이터를 저장하는 방식에는 2가지가 존재합니다. Java Hash 맵은 위에서 말햇듯 **Seperate Chaning(버킷을 분리시키고 체이닝 형식으로 저장)을 사용합니다**. 다른 방식으로는 Open Addressing(주소를 새로 열어 주소가 다른 버킷에 저장)이 있습니다.
    - Open Addressing은 버킷의 크기 자체를 늘리기 때문에 캐싱 적중률이 높습니다. 따라서 데이터의 크기가 작을 때는 Seperate Chaning보다 성능 상 이점이 있습니다. 하지만 배열이 커질 경우 캐싱 적중률이 떨어지기 때문에 효율성이 떨어집니다.