# godofjava
이상민님의 서적 '자바의신 2판'을 읽고 정리한 레포지토리입니다.

---

### 서평

백엔드 개발을 하며 가장 많이 사용하는 언어인 Java 기본서입니다. 기초부터 탄탄하게 잡아주며, 핵심을 쉽게 요약해서 전달해주는 부분이 좋았습니다. 책에 대한 설명이 너무 길 필요는 없고, 자바 기본서를 고민하신다면 남궁성님의 '자바의 정석'을 읽으시기 전에 이 책을 먼저 읽으시는 것도 좋습니다.

---

### Q&A: 객체와 클래스

- ***Q. 클래스와 객체의 차이점은 무엇일까요?***

  객체는 프로그래밍 기능의 분해 시 책임을 분배하기 위한 개념적인 요소라고 생각합니다. **클래스는 이러한 객체를 표현하기 위한 객체지향 언어의 도구**입니다. 
  
  - ***Q. 객체의 책임이란 무엇인가요?***
  
    책임이란 자신이 담당하는 프로그램의 기능입니다. 그런 의미에서 객체지향 패러다임이란 만들어야 하는 요구사항들을 객체들에게 적절하게 나누는 과정을 통해 프로그램을 설계하는 것이라고 생각합니다

- ***Q. 메서드와 메시지는 무엇이 다를까요?***

  메서드는 객체가 메시지를 수신했을 때 **자신의 책임을 수행하기 위해 선택하는 방법**입니다. 따라서 메서드는 실제 책임을 수행하기 위한 구현 방법, 코드를 의미합니다. 반면 **메시지는 객체가 소통하는 방법**을 의미합니다.
  
- ***Q. 캡슐화가 필요한 이유가 무엇일까요?***

  객체들이 서로의 세부 구현을 모르도록 만들어 **협력의 유연함을 증가시키고, 이를 통해 변경의 파급효과를 적절하게 통제**하기 위해서입니다. 객체는 퍼블릭 인터페이스를 통해 서로 커뮤니케이션합니다. 만약 캡슐화가 되어있지 않아 세부 구현에 대해 마음대로 접근할 수 있다면 객체 사이의 결합도가 늘어나게 됩니다.

  예를 들어 더하기라는 기능을 구현한다고 가정하겠습니다. 더하기에는 좌변에 수를 놓기, 우변에 수를 놓기, 더하기라는 세 개의 동작이 필요합니다. 만약 요청 객체가 좌변에 수를 놓기를 직접 가져다 쓴다면 나중에 좌변에 수를 놓는 동작이 변경되었을 때 그 객체도 변경되어야 합니다. 이것은 변경의 파급효과를 제어하지 못하는 것을 의미합니다. 따라서 캡슐화를 통해 변경이 적고 세부 구현을 감추는 퍼블릭 인터페이스만 노출시키는 것은 협력의 유연함을 늘리고 객체 간의 결합도를 줄일 수 있는 장점을 가질 수 있습니다.
  
- ***Q. Polymorphism, 다형성이란 무엇일까요?***
  
  **동일한 메시지를 수신하더라도 객체의 타입에 따라 다르게 응답할 수 있는 성질**을 말합니다. 인터페이스와 다형성을 통해서 객체지향에서는 컴파일 타임의 의존성을 제어할 수 있습니다.
  
  - ***Q. 어떻게 인터페이스와 다형성을 통해 제어하는지 설명해주세요.***
  
    컴파일 시점에서는 부모 클래스의 메서드인지, 자식 클래스의 메서드인지 구별하지 않고 동일한 메서드를 호출하지만 런타임에서 어떤 객체가 할당되어있는지에 따라 실행 결과가 달라집니다. 이를 통해 컴파일 타임의 의존성을 런타임으로 미룰 수 있습니다. **이 개념과 DI를 적절히 활용해 정책과 구현체의 의존성 방향 모두 인터페이스를 향하게 하도록 제어**할 수 있습니다.
    
- ***Q. 메서드 오버로딩이란 무엇일까요? 메서드 오버라이딩이란 무엇인가요? 그리고 둘은 무엇이 다른가요?***

  메서드 오버로딩이란 인자의 타입이나 수를 변경하여도 동일한 메서드 시그니처를 가지는 것을 허용해주는 기술입니다. 이를 통해 유사한 작업을 수행하는 메서드의 이름을 손쉽게 압축할 수 있습니다. 예를 들어 plus() 메서드를 구현할 때 단순한 숫자일수도, 돈일수도 있는데 이런 경우 사용이 가능합니다. 메서드 오버로딩은 컴파일 타임 시점에서 호출될 메서드의 종류를 선택하는 **정적 메서드 디스패칭**을 사용합니다.
  
  메서드 오버라이딩이란 부모 클래스로부터 상속받은 메서드와 동일한 시그니처의 메서드를 재정의해서 새로운 구현으로 부모 클래스의 구현을 대체하는 것을 말합니다. 이를 위해 필요한 것은 부모 클래스 타입 변수에 자식 클래스 인스턴스를 할당하는 업캐스팅과 **런타임 시점에 실행할 메서드를 탐색하는 다이나믹 메서드 디스패칭**입니다. 다이나믹 메서드 디스패칭이 수행될 때 중요한 것은 self 참조라는 임시변수입니다. 컴파일러는 self 참조라는 임시변수를 자동으로 생성하고 메시지를 수신한 객체를 가리킵니다. 여기서 부모 클래스 방향으로 올라가며 일치하는 메시지가 존재하는지를 확인합니다. 여기서 메서드 탐색은 메서드를 찾지 못한다면 자동적으로 부모 클래스에게 메서드에 대한 책임을 위임합니다.

- ***Q. 추상 클래스와 인터페이스에 대해 설명해주세요***

  추상 클래스는 상속 관계를 갖는 클래스들 사이에서 세부 구현을 공유해야할 필요가 있을 때, 즉 코드 재사용을 위해 사용됩니다. 인터페이스는 클래스들 사이에서 객체들의 책임만 정의하고 싶을 때 사용됩니다. 인터페이스는 주로 다형성을 통해 컴파일 타임 의존성을 끊어내기 위해 주로 사용됩니다.
        
---

### Q&A: 자료형

- ***Q. 기본 자료형과 참조 자료형이 메모리 상에서 저장되는 위치는 어디일까요?***

  두 데이터 모두 JVM 내부의 Runtime data area에 저장됩니다. 그 중 기본 자료형은 각 쓰레드의 고유한 스택 공간에 스택 프레임 형태로 저장됩니다. 참조 자료형은 Heap 영역에 저장됩니다. 만약 String 클래스라면 Heap 영역 중 String Constant Pool에 저장됩니다.
  
  - ***Q. 스택 프레임은 어떤 구조로 이루어져 있나요?***
  
    스택 프레임은 메서드의 지역 변수를 저장하는 **Local Variable Section**, 연산에 이용되는 데이터 및 결과를 저장하는 **Operand Stack**, **Frame Data**로 이루어져 있습니다. 최상단 스택 프레임을 current frame이라고 부릅니다. Local Variable Section는 0-Base 배열로 구성되어있고 로컬 변수와 메서드 파라미터가 저장됩니다. Operand Stack에는 연산에 사용되는 값들이 저장됩니다. Frame Data에는 다른 클래스를 참조하거나 메서드를 수행할 때 Constant Pool Resolution, Normal Method Return, Exception Dispatch가 있습니다.
    
- ***Q. 자바에서 0.1+0.2는 0.30...4가 나옵니다. 즉 컴퓨터는 소숫점 계산을 제대로 하지 못합니다. 그 이유가 무엇일까요?***

  double, long, float 계산 시 부동 소수점을 표현하기 위한 **IEEE 754를 사용**하기 때문입니다.
  
  - ***Q. 그렇다면 왜 IEEE 754 기술을 사용할까요?***
  
    소수점을 표현하는 방식에는 고정 소수점과 부동 소수점 방식이 존재합니다. 고정 소수점은 정수부와 소수부의 크기를 제한합니다. 즉 비트를 효율적으로 사용하지 못하는 것이죠. 따라서 과학적 표기법을 통해 유효한 숫자만 표시할 수 있도록 하기 위해 부동 소수점 방식을 사용합니다. 그리고 이렇게 소수점을 소수부의 가장 첫번째 자리까지 당겨오는 것을 정규화라고 합니다.
    
    하지만 부동 소수점은 가수의 자리수를 32비트에서는 23자리, 64비트에서는 52자리로 제한하기 때문에 표현하고자 하는 소수부의 **이진법 표기가 무한소수로 표기되는 경우 결국 일부분을 잘라낼 수 밖에 없게** 됩니다. 이 때문에 값의 오차가 발생합니다.
    
    - ***Q. 32비트에서 64비트로 올라가면 정밀도가 향상된다구요? 그럼 정밀도란 무엇일까요?***
    
      숫자의 오차가 얼마나 적은지 입니다. 위에서 말했듯 비트 크기의 한계 때문에 결국 일부분이 끊기는데, 비트 크기가 크다면 최대한 잘리는 비트의 수가 적어질 것이고 실제값에 더 가까워질 수 있습니다.
      
      - ***Q. 자바에서 BigDecimal은 어떻게 이런 문제를 해결할까요?***

        BigDecimal은 정수를 저장하는 `BigInt` 타입의 `intValue` 필드, 지수를 나타내는 `scale`, 정밀도를 나타내는 `precision` 세 개의 필드를 사용해 소수를 표시합니다. 예를 들어 표시하고자 하는 숫자가 123.45라면 { `intValue`: 12345, `scale`: 2, `precision`: 5 } 의 값을 가지게 됩니다.
        
- ***Q. pass by value, pass by reference에 대해서 설명해주세요***
  
  메서드의 매개변수가 전달될 때 인자의 자료형에 따라 ‘값' 혹은 ‘주소’가 전달되는 것을 말합니다. 인자가 **primitive 타입인 경우는 복사된 값**만 전달되어, 즉 원본에 영향을 끼칠 수 없습니다. 이는 메서드 호출 시 매개변수가 스택 프레임에 어떻게 쌓이는지에 대한 이해가 필요합니다. 메서드 호출 시 스택 프레임에는 Return Address가 쌓이고, 매개변수로 전달된 값 혹은 객체 역시 새롭게 쌓입니다. 이 때 인자는 매개변수로 전달된 원본에서 값만 복사한 것입니다. 즉 원본이랑은 전혀 관련이 없기 때문에, 원본에 대한 접근 자체가 불가능합니다.
  
  반면 참조형 객체는 **값이 아닌 '참조 주소 복사본(a copy of the object address)'** 이 전달됩니다. 즉 전달된 인자가 원본과 같은 곳을 보고 있다는 것이죠. 따라서 전달된 복사본의 필드에 접근, 수정이 가능합니다. 이러한 참조 주소의 복사본, 'Object Reference'를 통해서는 { 필드 접근, 메서드 호출, 현변환 연산자, String + 연산자 , instanceof, ==, =!, ?: } 연산만 가능합니다. 인수로 전달된 복사본은 원본 자체가 아닌 단순히 메모리 주소값입니다. 따라서 메서드 내부에서 재할당을 시도하더라도, 원본 주소의 복사본일 뿐이므로 메서드 스코프가 종료되면 복사본이 손실되고 원본 반영은 일어나지 않습니다.
  
 ---
 
 ### Q&A: 형 변환
 
 - ***Q. auto boxing, unboxing 이란 무엇인가요?***
 
	Wrapper 클래스와 primitive 타입 사이에서 메서드의 파라미터를 통과할 때와 변수로 할당될 때 서로간 캐스팅을 해주는 것을 말합니다. 주로 기본 타입을 담을 수 없는 컬렉션에서 많이 사용됩니다.
    
  	- ***Q. Wrapper Class란 무엇인가요?***

		**객체 형태가 되도록 한번 감싼 형태의 클래스**를 말합니다. JDK가 제공하는 래퍼 클래스들은 인스턴스 풀링을 제공합니다. 따라서 각 래퍼 클래스들은 캐시 형태로 자주, 일반적으로 사용되는 인스턴스들의 목록을 저장해놓고 필요할 때마다 사용하는 방식을 취합니다.
      
    	예를 들어 Integer class에서는 IntegerCache라는 정적 내부 클래스를 갖고 있습니다. 이 클래스는 처음 사용될 때만 초기화됩니다. 비록 캐시를 생성하는 것때문에 처음에는 시간이 조금 걸리지만, 후에는 **메모리를 재사용**한다는 장점을 갖고 있습니다. 하지만 new 연산자를 사용하는 경우 적용되지 않습니다. 이 경우는 리소스 풀이 아닌 힙 영역에 생성되며, Integer.valueOf() 혹은 기본값 타입을 할당하는 경우만 캐싱이 적용됩니다.
      
    	즉 내부 캐시를 사용하기 위해선 항상 기본 할당을 사용하여 변수를 참조하거나 `valueOf()` 메서드를 사용해야 합니다. 캐싱의 기본값은 -128~127이며 이 사이의 값이 들어온 경우 미리 생성되어 캐싱된 인스턴스를 반환합니다. 만약 런타임에 사용하는 값들이 디폴트 설정보다 크다면 runtime args 설정이나 JVM 옵션을 통해 조정이 가능합니다.
      
    	- ***Q. 인스턴스 풀링이 무엇인가요?***

      		자바에서는 대부분 new 생성자를 통해서 클래스 인스턴스를 초기화합니다. 이 인스턴스들은 heap 영역에 생성되며 대부분 무거운 작업으로 간주됩니다. 따라서 대부분의 프레임워크에서는 이를 해결하기 위해 리소스 풀링이라는 방법을 사용합니다. Persistence framework에서는 커넥션 풀을, 자바에서는 String Pool 개념을 사용합니다. 우린 이 목적을 위해 프로토타입 패턴을 사용합니다. 미리 만들어진 객체를 사용하는 것은 굉장히 큰 도움이 됩니다.
       
- ***Q. 업캐스팅과 다운캐스팅***

  	자식(하위) 클래스에서 부모(상위) 클래스로 캐스팅되는 것을 업캐스팅, 반대를 다운캐스팅이라고 합니다. 이를 사용하는 이유는 객체지향의 다형성 메커니즘과 연관되어 있습니다. 다형성이란 간단하게는 추상 인터페이스에 대해 서로 다른 구현을 연결할 수 있는 성질인데요. 업캐스팅을 통해 자식 클래스가 부모 클래스의 메서드를 사용할 수 있습니다.

---

### Q&A: Object Class

- ***Q. Object가 지원하는 hashcode(, equals() 메서드에 대해서 설명해주세요.***

	`equals()` 메서드는 객체의 동등성을 체크하기 위한 메서드입니다. 하지만 컴퓨터는 우리가 인지하는 **‘같다'라는 개념을 기본적으로 인스턴스의 메모리 주소값을 통해 비교**합니다. 이 때 인스턴스의 메모리 주소값을 16진수로 표현한 int 타입으로 리턴하는 메서드가 `hashcode()`입니다.
	
	- ***Q. 왜 필요할까요?***

		예를 들어 대한민국 국민이라는 객체를 표현한다고 가정해보겠습니다. 이 때 주민등록번호가 같다면 우린 같다고 인지합니다. 하지만 동일한 주민등록번호를 가진 인스턴스가 n개가 올라갔을 때 해당 인스턴스들은 **모두 다른 메모리 주소를 가질 것**입니다. 그렇다면 컴퓨터는 우리가 관념적으로는 같다고 인지함에도 불구하고 다르다는 결과를 뱉을 것입니다. 따라서 같다라는 개념을 정의하는 것은 굉장히 중요합니다.
		- ***Q. 만약 컴퓨터에게 '같다'라는 개념을 제대로 인식시키지 못한다면 어떤 문제가 발생할까요?***

			만약 같다라는 개념을 제대로 정의하지 못한다면 Map 자료구조의 자료 입출력 혹은 데이터베이스에서 자료를 조회할 때 혹은 메모리 캐시를 제대로 사용할 수 없습니다. 이런 문제점들은 Hibernate에서는 `@Entity`의 `@Id`를 통해서, Java 14부터는 `record` 키워드를 통해 혹은 직접 구현해 해결할 수 있습니다.
			
---

### Q&A: Enum Class

- ***Q. Enum 클래스가 무엇인가요?***

	클래스의 모양을 띤 상수입니다. JDK 1.5부터 추가됐습니다. 이전에는 public static final 형태 혹은 인터페이스의 변수로 많이 지정이 되었었습니다. 현재 근무하는 곳에서도 이런 형태를 띄고 있어 Enum 클래스로 마이그레이션하는 작업을 진행하는 경우가 많습니다. 
	
	- ***Q. 혹시 상속이 가능할까요?***

		enum클래스는 내부적으로 Enum<T>를 상속받습니다. 따라서 **다른 클래스를 extend 할 수 없습니다**. 이펙티브 자바에서는 이런 enum의 기능을 계승해서 사용하고 싶다면 interface를 생성 + 구현하여 사용하는 방식을 권장합니다. Java 17에서는 이런 문제를 `sealed class, interface`를 통해 해결할 수 있습니다.
